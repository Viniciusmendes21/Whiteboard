{"ast":null,"code":"import { BehaviorSubject, combineLatest } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let CanvasService = /*#__PURE__*/(() => {\n  class CanvasService {\n    constructor() {\n      this.elementsSubject = new BehaviorSubject([]);\n      this.zoomSubject = new BehaviorSubject(1);\n      this.panSubject = new BehaviorSubject({\n        x: 0,\n        y: 0\n      });\n      this.snapToGridSubject = new BehaviorSubject(false);\n      this.gridSizeSubject = new BehaviorSubject(20);\n      this.themeSubject = new BehaviorSubject('light');\n      this.isApplyingRemote = false;\n      this.instanceId = `${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      this.elements$ = this.elementsSubject.asObservable();\n      this.zoom$ = this.zoomSubject.asObservable();\n      this.pan$ = this.panSubject.asObservable();\n      this.snapToGrid$ = this.snapToGridSubject.asObservable();\n      this.gridSize$ = this.gridSizeSubject.asObservable();\n      this.theme$ = this.themeSubject.asObservable();\n      this.setupBroadcast();\n      this.applyTheme(this.themeSubject.value);\n    }\n    get elements() {\n      return this.elementsSubject.value;\n    }\n    get zoom() {\n      return this.zoomSubject.value;\n    }\n    get pan() {\n      return this.panSubject.value;\n    }\n    get snapToGrid() {\n      return this.snapToGridSubject.value;\n    }\n    get gridSize() {\n      return this.gridSizeSubject.value;\n    }\n    get theme() {\n      return this.themeSubject.value;\n    }\n    addElement(element) {\n      const zIndex = element.zIndex ?? (this.elements.length ? Math.max(...this.elements.map(e => e.zIndex ?? 0)) + 1 : 0);\n      const elements = [...this.elements, {\n        ...element,\n        zIndex\n      }];\n      this.elementsSubject.next(elements);\n    }\n    updateElement(id, updates) {\n      const elements = this.elements.map(el => el.id === id ? {\n        ...el,\n        ...updates\n      } : el);\n      this.elementsSubject.next(elements);\n    }\n    updateSelectedTextStyle(style) {\n      const elements = this.elements.map(el => {\n        if (!el.isSelected || !el.text) return el;\n        return {\n          ...el,\n          fontSize: style.fontSize ?? el.fontSize,\n          fontFamily: style.fontFamily ?? el.fontFamily,\n          fontWeight: style.fontWeight ?? el.fontWeight,\n          fontStyle: style.fontStyle ?? el.fontStyle,\n          strokeColor: style.strokeColor ?? el.strokeColor\n        };\n      });\n      this.elementsSubject.next(elements);\n    }\n    updateSelectedDimensions(dimensions) {\n      const elements = this.elements.map(el => {\n        if (!el.isSelected) return el;\n        return {\n          ...el,\n          width: dimensions.width ?? el.width,\n          height: dimensions.height ?? el.height\n        };\n      });\n      this.elementsSubject.next(elements);\n    }\n    setElements(elements) {\n      this.elementsSubject.next(elements);\n    }\n    deleteElement(id) {\n      const elements = this.elements.filter(el => el.id !== id);\n      this.elementsSubject.next(elements);\n    }\n    deleteSelectedElements() {\n      const elements = this.elements.filter(el => !el.isSelected);\n      this.elementsSubject.next(elements);\n      this.normalizeZIndices();\n    }\n    clearSelection() {\n      const elements = this.elements.map(el => ({\n        ...el,\n        isSelected: false\n      }));\n      this.elementsSubject.next(elements);\n    }\n    selectElement(id, addToSelection = false) {\n      const elements = this.elements.map(el => ({\n        ...el,\n        isSelected: el.id === id ? true : addToSelection ? el.isSelected : false\n      }));\n      this.elementsSubject.next(elements);\n    }\n    setZoom(zoom) {\n      this.zoomSubject.next(Math.max(0.1, Math.min(5, zoom)));\n    }\n    setPan(pan) {\n      this.panSubject.next(pan);\n    }\n    setSnapToGrid(enabled) {\n      this.snapToGridSubject.next(enabled);\n    }\n    setGridSize(size) {\n      const clamped = Math.max(5, Math.min(200, size));\n      this.gridSizeSubject.next(clamped);\n    }\n    rotateSelected(deltaDeg) {\n      const elements = this.elements.map(el => el.isSelected ? {\n        ...el,\n        rotation: (el.rotation + deltaDeg) % 360\n      } : el);\n      this.elementsSubject.next(elements);\n    }\n    alignSelected(alignment) {\n      const selected = this.elements.filter(el => el.isSelected);\n      if (selected.length < 2) return;\n      const bounds = this.getBounds(selected);\n      const updated = this.elements.map(el => {\n        if (!el.isSelected) return el;\n        const w = el.width || 0;\n        const h = el.height || 0;\n        switch (alignment) {\n          case 'left':\n            return {\n              ...el,\n              x: bounds.minX\n            };\n          case 'right':\n            return {\n              ...el,\n              x: bounds.maxX - w\n            };\n          case 'top':\n            return {\n              ...el,\n              y: bounds.minY\n            };\n          case 'bottom':\n            return {\n              ...el,\n              y: bounds.maxY - h\n            };\n          case 'center':\n            return {\n              ...el,\n              x: bounds.minX + (bounds.width - w) / 2\n            };\n          case 'middle':\n            return {\n              ...el,\n              y: bounds.minY + (bounds.height - h) / 2\n            };\n        }\n      });\n      this.elementsSubject.next(updated);\n    }\n    distributeSelected(orientation) {\n      const selected = this.elements.filter(el => el.isSelected).sort((a, b) => orientation === 'horizontal' ? a.x - b.x : a.y - b.y);\n      if (selected.length < 3) return;\n      const bounds = this.getBounds(selected);\n      const gaps = selected.length - 1;\n      if (orientation === 'horizontal') {\n        const totalWidth = selected.reduce((sum, el) => sum + Math.abs(el.width || 0), 0);\n        const space = bounds.width - totalWidth;\n        let cursor = bounds.minX;\n        const updatedIds = new Set(selected.map(s => s.id));\n        const updated = this.elements.map(el => {\n          if (!updatedIds.has(el.id)) return el;\n          const w = Math.abs(el.width || 0);\n          const next = {\n            ...el,\n            x: cursor\n          };\n          cursor += w + space / gaps;\n          return next;\n        });\n        this.elementsSubject.next(updated);\n      } else {\n        const totalHeight = selected.reduce((sum, el) => sum + Math.abs(el.height || 0), 0);\n        const space = bounds.height - totalHeight;\n        let cursor = bounds.minY;\n        const updatedIds = new Set(selected.map(s => s.id));\n        const updated = this.elements.map(el => {\n          if (!updatedIds.has(el.id)) return el;\n          const h = Math.abs(el.height || 0);\n          const next = {\n            ...el,\n            y: cursor\n          };\n          cursor += h + space / gaps;\n          return next;\n        });\n        this.elementsSubject.next(updated);\n      }\n    }\n    groupSelected() {\n      const selected = this.elements.filter(el => el.isSelected);\n      if (selected.length < 2) return;\n      const groupId = `group-${Date.now()}-${Math.random().toString(36).slice(2)}`;\n      const elements = this.elements.map(el => el.isSelected ? {\n        ...el,\n        groupId\n      } : el);\n      this.elementsSubject.next(elements);\n    }\n    ungroupSelected() {\n      const elements = this.elements.map(el => el.isSelected ? {\n        ...el,\n        groupId: undefined\n      } : el);\n      this.elementsSubject.next(elements);\n    }\n    bringToFront() {\n      const selectedIds = new Set(this.elements.filter(el => el.isSelected).map(el => el.id));\n      if (!selectedIds.size) return;\n      const reordered = [...this.elements].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0)).map((el, idx) => ({\n        ...el,\n        zIndex: idx\n      }));\n      const max = reordered.length - 1;\n      const bumped = reordered.map(el => selectedIds.has(el.id) ? {\n        ...el,\n        zIndex: max + 1\n      } : el);\n      this.elementsSubject.next(this.sortByZIndex(bumped));\n      this.normalizeZIndices();\n    }\n    sendToBack() {\n      const selectedIds = new Set(this.elements.filter(el => el.isSelected).map(el => el.id));\n      if (!selectedIds.size) return;\n      const reordered = [...this.elements].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0)).map((el, idx) => ({\n        ...el,\n        zIndex: idx\n      }));\n      const bumped = reordered.map(el => selectedIds.has(el.id) ? {\n        ...el,\n        zIndex: -1\n      } : el);\n      this.elementsSubject.next(this.sortByZIndex(bumped));\n      this.normalizeZIndices();\n    }\n    insertTemplate(name) {\n      const baseX = 50;\n      const baseY = 80;\n      const palette = ['#FFEB3B', '#FFCDD2', '#C5E1A5', '#BBDEFB'];\n      let elements = [];\n      if (name === 'sticky-notes') {\n        elements = palette.map((color, idx) => ({\n          id: this.generateId(),\n          type: 'rectangle',\n          x: baseX + idx * 140,\n          y: baseY,\n          width: 120,\n          height: 120,\n          strokeColor: '#444',\n          fillColor: color,\n          strokeWidth: 2,\n          rotation: 0,\n          text: 'Nota'\n        }));\n      } else {\n        elements = [{\n          id: this.generateId(),\n          type: 'rectangle',\n          x: baseX,\n          y: baseY,\n          width: 160,\n          height: 90,\n          strokeColor: '#1976d2',\n          fillColor: '#E3F2FD',\n          strokeWidth: 2,\n          rotation: 0,\n          text: 'Início'\n        }, {\n          id: this.generateId(),\n          type: 'ellipse',\n          x: baseX + 220,\n          y: baseY,\n          width: 140,\n          height: 90,\n          strokeColor: '#388e3c',\n          fillColor: '#E8F5E9',\n          strokeWidth: 2,\n          rotation: 0,\n          text: 'Decisão'\n        }, {\n          id: this.generateId(),\n          type: 'arrow',\n          x: baseX + 160,\n          y: baseY + 45,\n          width: 60,\n          height: 0,\n          strokeColor: '#444',\n          fillColor: '#444',\n          strokeWidth: 3,\n          rotation: 0\n        }];\n      }\n      const currentMaxZ = this.elements.length ? Math.max(...this.elements.map(el => el.zIndex ?? 0)) : 0;\n      const withZ = elements.map((el, idx) => ({\n        ...el,\n        zIndex: currentMaxZ + idx + 1\n      }));\n      this.elementsSubject.next([...this.elements, ...withZ]);\n    }\n    setTheme(theme) {\n      this.themeSubject.next(theme);\n      this.applyTheme(theme);\n    }\n    clear() {\n      this.elementsSubject.next([]);\n      this.zoomSubject.next(1);\n      this.panSubject.next({\n        x: 0,\n        y: 0\n      });\n      this.snapToGridSubject.next(false);\n      this.gridSizeSubject.next(20);\n      this.themeSubject.next('light');\n    }\n    getState() {\n      return {\n        elements: [...this.elements],\n        zoom: this.zoom,\n        panX: this.pan.x,\n        panY: this.pan.y,\n        snapToGrid: this.snapToGrid,\n        gridSize: this.gridSize\n      };\n    }\n    setState(state) {\n      this.elementsSubject.next([...state.elements]);\n      this.zoomSubject.next(state.zoom);\n      this.panSubject.next({\n        x: state.panX,\n        y: state.panY\n      });\n      this.snapToGridSubject.next(!!state.snapToGrid);\n      this.gridSizeSubject.next(state.gridSize ?? 20);\n    }\n    exportToJSON() {\n      return JSON.stringify(this.getState(), null, 2);\n    }\n    importFromJSON(json) {\n      try {\n        const state = JSON.parse(json);\n        this.setState(state);\n        return true;\n      } catch {\n        return false;\n      }\n    }\n    generateId() {\n      return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n    getBounds(elements) {\n      const xs = elements.map(el => [el.x, el.x + (el.width || 0)]).flat();\n      const ys = elements.map(el => [el.y, el.y + (el.height || 0)]).flat();\n      const minX = Math.min(...xs);\n      const maxX = Math.max(...xs);\n      const minY = Math.min(...ys);\n      const maxY = Math.max(...ys);\n      return {\n        minX,\n        maxX,\n        minY,\n        maxY,\n        width: maxX - minX,\n        height: maxY - minY\n      };\n    }\n    normalizeZIndices() {\n      const sorted = this.sortByZIndex(this.elements);\n      const normalized = sorted.map((el, idx) => ({\n        ...el,\n        zIndex: idx\n      }));\n      this.elementsSubject.next(normalized);\n    }\n    sortByZIndex(elements) {\n      return [...elements].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n    }\n    applyTheme(theme) {\n      const body = document.body;\n      body.classList.remove('theme-light', 'theme-dark');\n      body.classList.add(`theme-${theme}`);\n    }\n    setupBroadcast() {\n      if (typeof BroadcastChannel === 'undefined') return;\n      this.broadcastChannel = new BroadcastChannel('whiteboard-sync');\n      this.broadcastChannel.onmessage = event => {\n        const {\n          origin,\n          state\n        } = event.data || {};\n        if (!state || origin === this.instanceId) return;\n        this.isApplyingRemote = true;\n        this.setState(state);\n        this.isApplyingRemote = false;\n      };\n      combineLatest([this.elements$, this.zoom$, this.pan$, this.snapToGrid$, this.gridSize$]).subscribe(([elements, zoom, pan, snap, grid]) => {\n        if (!this.broadcastChannel || this.isApplyingRemote) return;\n        const state = {\n          elements,\n          zoom,\n          panX: pan.x,\n          panY: pan.y,\n          snapToGrid: snap,\n          gridSize: grid\n        };\n        this.broadcastChannel.postMessage({\n          origin: this.instanceId,\n          state\n        });\n      });\n    }\n    static {\n      this.ɵfac = function CanvasService_Factory(t) {\n        return new (t || CanvasService)();\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: CanvasService,\n        factory: CanvasService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return CanvasService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}