{"ast":null,"code":"import { Subject, takeUntil } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/canvas.service\";\nimport * as i2 from \"../../services/tool.service\";\nimport * as i3 from \"../../services/history.service\";\nimport * as i4 from \"@angular/common\";\nimport * as i5 from \"@angular/forms\";\nconst _c0 = [\"canvas\"];\nconst _c1 = [\"textEditor\"];\nconst _c2 = (a0, a1, a2, a3) => ({\n  top: a0,\n  left: a1,\n  width: a2,\n  height: a3\n});\nfunction CanvasComponent_textarea_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"textarea\", 5, 1);\n    i0.ɵɵtwoWayListener(\"ngModelChange\", function CanvasComponent_textarea_3_Template_textarea_ngModelChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r2 = i0.ɵɵnextContext();\n      i0.ɵɵtwoWayBindingSet(ctx_r2.editValue, $event) || (ctx_r2.editValue = $event);\n      return i0.ɵɵresetView($event);\n    });\n    i0.ɵɵlistener(\"keydown\", function CanvasComponent_textarea_3_Template_textarea_keydown_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.onInlineEditKeydown($event));\n    })(\"blur\", function CanvasComponent_textarea_3_Template_textarea_blur_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.commitInlineEdit());\n    })(\"mousedown\", function CanvasComponent_textarea_3_Template_textarea_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r2);\n      return i0.ɵɵresetView($event.stopPropagation());\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction4(2, _c2, ctx_r2.editPosition.top + \"px\", ctx_r2.editPosition.left + \"px\", ctx_r2.editPosition.width + \"px\", ctx_r2.editPosition.height + \"px\"));\n    i0.ɵɵtwoWayProperty(\"ngModel\", ctx_r2.editValue);\n  }\n}\nexport let CanvasComponent = /*#__PURE__*/(() => {\n  class CanvasComponent {\n    constructor(canvasService, toolService, historyService) {\n      this.canvasService = canvasService;\n      this.toolService = toolService;\n      this.historyService = historyService;\n      this.isDrawing = false;\n      this.startPoint = {\n        x: 0,\n        y: 0\n      };\n      this.currentElement = null;\n      this.destroy$ = new Subject();\n      this.isPanning = false;\n      this.lastPanPoint = {\n        x: 0,\n        y: 0\n      };\n      this.isDraggingSelection = false;\n      this.dragStartPoint = null;\n      this.dragInitialPositions = {};\n      this.isResizing = false;\n      this.resizeHandle = null;\n      this.resizeStartPoint = null;\n      this.resizeInitial = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        id: ''\n      };\n      this.handleSize = 10;\n      this.editingElementId = null;\n      this.editValue = '';\n      this.editPosition = {\n        top: 0,\n        left: 0,\n        width: 140,\n        height: 36\n      };\n    }\n    ngAfterViewInit() {\n      this.initCanvas();\n      this.setupSubscriptions();\n      this.render();\n    }\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n    initCanvas() {\n      const canvas = this.canvasRef.nativeElement;\n      this.ctx = canvas.getContext('2d');\n      this.resizeCanvas();\n    }\n    setupSubscriptions() {\n      this.canvasService.elements$.pipe(takeUntil(this.destroy$)).subscribe(() => this.render());\n      this.canvasService.zoom$.pipe(takeUntil(this.destroy$)).subscribe(() => this.render());\n      this.canvasService.pan$.pipe(takeUntil(this.destroy$)).subscribe(() => this.render());\n    }\n    resizeCanvas() {\n      const canvas = this.canvasRef.nativeElement;\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n      this.render();\n    }\n    handleKeyDown(event) {\n      if (event.ctrlKey && event.key === 'z') {\n        event.preventDefault();\n        const state = this.historyService.undo();\n        if (state) this.canvasService.setState(state);\n      } else if (event.ctrlKey && event.key === 'y') {\n        event.preventDefault();\n        const state = this.historyService.redo();\n        if (state) this.canvasService.setState(state);\n      } else if (event.key === 'Delete') {\n        event.preventDefault();\n        this.canvasService.deleteSelectedElements();\n        this.historyService.addState(this.canvasService.getState());\n      }\n    }\n    onDoubleClick(event) {\n      const point = this.getCanvasPoint(event, false);\n      const target = this.findTopElement(point);\n      if (target && target.text) {\n        this.startInlineEdit(target);\n      }\n    }\n    onMouseDown(event) {\n      const tool = this.toolService.currentTool;\n      const shouldSnap = this.canvasService.snapToGrid && tool !== 'select' && tool !== 'pan';\n      const point = this.getCanvasPoint(event, shouldSnap);\n      if (tool === 'pan') {\n        this.isPanning = true;\n        this.lastPanPoint = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        return;\n      }\n      // Auto-seleciona elementos mesmo quando outra ferramenta está ativa\n      if (tool === 'select') {\n        const handleHit = this.hitHandle(point);\n        if (handleHit) {\n          this.isResizing = true;\n          this.resizeHandle = handleHit.handle;\n          this.resizeStartPoint = point;\n          this.resizeInitial = {\n            x: handleHit.element.x,\n            y: handleHit.element.y,\n            width: handleHit.element.width || this.measureElementWidth(handleHit.element),\n            height: handleHit.element.height || this.measureElementHeight(handleHit.element),\n            id: handleHit.element.id\n          };\n          return;\n        }\n      }\n      if (tool === 'select') {\n        const target = this.findTopElement(point);\n        if (target) {\n          if (!target.isSelected && !event.shiftKey) {\n            this.canvasService.clearSelection();\n          }\n          this.canvasService.selectElement(target.id, event.shiftKey);\n          this.startSelectionDrag(point);\n        } else {\n          if (!event.shiftKey) {\n            this.canvasService.clearSelection();\n          }\n          this.isDraggingSelection = false;\n        }\n        return;\n      }\n      this.isDrawing = true;\n      this.startPoint = point;\n      this.canvasService.clearSelection();\n      this.currentElement = {\n        id: this.canvasService.generateId(),\n        type: tool,\n        x: point.x,\n        y: point.y,\n        strokeColor: this.toolService.strokeColor,\n        fillColor: this.toolService.fillColor,\n        strokeWidth: this.toolService.strokeWidth,\n        fontSize: this.toolService.fontSize,\n        fontFamily: this.toolService.fontFamily,\n        fontStyle: this.toolService.fontStyle,\n        fontWeight: this.toolService.fontWeight,\n        rotation: 0,\n        points: tool === 'freedraw' ? [point] : []\n      };\n      if (tool === 'text') {\n        this.handleTextInput(point);\n      }\n    }\n    onMouseMove(event) {\n      if (this.isPanning) {\n        const dx = event.clientX - this.lastPanPoint.x;\n        const dy = event.clientY - this.lastPanPoint.y;\n        const pan = this.canvasService.pan;\n        this.canvasService.setPan({\n          x: pan.x + dx,\n          y: pan.y + dy\n        });\n        this.lastPanPoint = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        return;\n      }\n      if (this.isDraggingSelection && this.dragStartPoint) {\n        const point = this.getCanvasPoint(event, this.canvasService.snapToGrid);\n        const dx = point.x - this.dragStartPoint.x;\n        const dy = point.y - this.dragStartPoint.y;\n        const size = this.canvasService.gridSize;\n        const updated = this.canvasService.elements.map(el => {\n          if (!el.isSelected) return el;\n          const base = this.dragInitialPositions[el.id] || {\n            x: el.x,\n            y: el.y\n          };\n          let x = base.x + dx;\n          let y = base.y + dy;\n          if (this.canvasService.snapToGrid) {\n            x = Math.round(x / size) * size;\n            y = Math.round(y / size) * size;\n          }\n          return {\n            ...el,\n            x,\n            y\n          };\n        });\n        this.canvasService.setElements(updated);\n        this.render();\n        return;\n      }\n      if (this.isResizing && this.resizeHandle && this.resizeStartPoint) {\n        const point = this.getCanvasPoint(event, false);\n        const dx = point.x - this.resizeStartPoint.x;\n        const dy = point.y - this.resizeStartPoint.y;\n        const el = this.canvasService.elements.find(e => e.id === this.resizeInitial.id);\n        if (!el) return;\n        let newX = this.resizeInitial.x;\n        let newY = this.resizeInitial.y;\n        let newW = this.resizeInitial.width || 0;\n        let newH = this.resizeInitial.height || 0;\n        const minSize = 10;\n        switch (this.resizeHandle) {\n          case 'se':\n            newW = Math.max(minSize, this.resizeInitial.width + dx);\n            newH = Math.max(minSize, this.resizeInitial.height + dy);\n            break;\n          case 'ne':\n            newW = Math.max(minSize, this.resizeInitial.width + dx);\n            newH = Math.max(minSize, this.resizeInitial.height - dy);\n            newY = this.resizeInitial.y + dy;\n            break;\n          case 'sw':\n            newW = Math.max(minSize, this.resizeInitial.width - dx);\n            newH = Math.max(minSize, this.resizeInitial.height + dy);\n            newX = this.resizeInitial.x + dx;\n            break;\n          case 'nw':\n            newW = Math.max(minSize, this.resizeInitial.width - dx);\n            newH = Math.max(minSize, this.resizeInitial.height - dy);\n            newX = this.resizeInitial.x + dx;\n            newY = this.resizeInitial.y + dy;\n            break;\n          case 'e':\n            newW = Math.max(minSize, this.resizeInitial.width + dx);\n            break;\n          case 'w':\n            newW = Math.max(minSize, this.resizeInitial.width - dx);\n            newX = this.resizeInitial.x + dx;\n            break;\n          case 's':\n            newH = Math.max(minSize, this.resizeInitial.height + dy);\n            break;\n          case 'n':\n            newH = Math.max(minSize, this.resizeInitial.height - dy);\n            newY = this.resizeInitial.y + dy;\n            break;\n        }\n        this.canvasService.updateElement(el.id, {\n          x: newX,\n          y: newY,\n          width: newW,\n          height: newH\n        });\n        return;\n      }\n      if (!this.isDrawing || !this.currentElement) return;\n      const tool = this.toolService.currentTool;\n      const shouldSnap = this.canvasService.snapToGrid && tool !== 'select' && tool !== 'pan';\n      const point = this.getCanvasPoint(event, shouldSnap);\n      if (tool === 'freedraw') {\n        this.currentElement.points.push(point);\n      } else {\n        this.currentElement.width = point.x - this.startPoint.x;\n        this.currentElement.height = point.y - this.startPoint.y;\n      }\n      this.render();\n      if (this.currentElement) {\n        this.drawElement(this.currentElement);\n      }\n    }\n    onMouseUp(event) {\n      if (this.isPanning) {\n        this.isPanning = false;\n        return;\n      }\n      if (this.isResizing) {\n        this.isResizing = false;\n        this.resizeHandle = null;\n        this.resizeStartPoint = null;\n        this.historyService.addState(this.canvasService.getState());\n        return;\n      }\n      if (this.isDraggingSelection) {\n        this.isDraggingSelection = false;\n        this.dragStartPoint = null;\n        this.dragInitialPositions = {};\n        this.historyService.addState(this.canvasService.getState());\n        return;\n      }\n      if (!this.isDrawing || !this.currentElement) return;\n      if (this.toolService.currentTool !== 'text') {\n        this.canvasService.addElement(this.currentElement);\n        this.historyService.addState(this.canvasService.getState());\n      }\n      this.isDrawing = false;\n      this.currentElement = null;\n    }\n    onWheel(event) {\n      if (event.ctrlKey) {\n        event.preventDefault();\n        const delta = event.deltaY > 0 ? 0.9 : 1.1;\n        this.canvasService.setZoom(this.canvasService.zoom * delta);\n      }\n    }\n    getCanvasPoint(event, snapToGrid = false) {\n      const canvas = this.canvasRef.nativeElement;\n      const rect = canvas.getBoundingClientRect();\n      const zoom = this.canvasService.zoom;\n      const pan = this.canvasService.pan;\n      let x = (event.clientX - rect.left - pan.x) / zoom;\n      let y = (event.clientY - rect.top - pan.y) / zoom;\n      if (snapToGrid && this.canvasService.snapToGrid) {\n        const size = this.canvasService.gridSize;\n        x = Math.round(x / size) * size;\n        y = Math.round(y / size) * size;\n      }\n      return {\n        x,\n        y\n      };\n    }\n    handleSelection(point, addToSelection) {\n      const elements = this.canvasService.elements;\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const el = elements[i];\n        if (this.isPointInElement(point, el)) {\n          this.canvasService.selectElement(el.id, addToSelection);\n          return;\n        }\n      }\n      if (!addToSelection) {\n        this.canvasService.clearSelection();\n      }\n    }\n    isPointInElement(point, element) {\n      if (element.type === 'freedraw') {\n        return element.points?.some(p => Math.abs(p.x - point.x) < 10 && Math.abs(p.y - point.y) < 10) || false;\n      }\n      const x = element.x;\n      const y = element.y;\n      const w = element.width || 0;\n      const h = element.height || 0;\n      return point.x >= Math.min(x, x + w) && point.x <= Math.max(x, x + w) && point.y >= Math.min(y, y + h) && point.y <= Math.max(y, y + h);\n    }\n    handleTextInput(point) {\n      if (this.currentElement) {\n        const text = '';\n        this.currentElement.text = text;\n        this.currentElement.width = 100;\n        this.currentElement.height = this.measureElementHeight({\n          ...this.currentElement,\n          text\n        });\n        this.canvasService.addElement(this.currentElement);\n        this.canvasService.clearSelection();\n        this.canvasService.selectElement(this.currentElement.id, false);\n        this.startInlineEdit(this.currentElement);\n      }\n      this.isDrawing = false;\n      this.currentElement = null;\n    }\n    findTopElement(point) {\n      const elements = [...this.canvasService.elements].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n      for (let i = elements.length - 1; i >= 0; i--) {\n        if (this.isPointInElement(point, elements[i])) {\n          return elements[i];\n        }\n      }\n      return null;\n    }\n    startSelectionDrag(point) {\n      this.isDraggingSelection = true;\n      this.dragStartPoint = point;\n      this.dragInitialPositions = {};\n      this.canvasService.elements.forEach(el => {\n        if (el.isSelected) {\n          this.dragInitialPositions[el.id] = {\n            x: el.x,\n            y: el.y\n          };\n        }\n      });\n    }\n    hitHandle(point) {\n      const selected = this.canvasService.elements.find(el => el.isSelected);\n      if (!selected) return null;\n      const bounds = this.getElementBounds(selected);\n      const hs = this.handleSize;\n      const handles = [{\n        handle: 'nw',\n        x: bounds.x - hs / 2,\n        y: bounds.y - hs / 2\n      }, {\n        handle: 'n',\n        x: bounds.x + bounds.width / 2 - hs / 2,\n        y: bounds.y - hs / 2\n      }, {\n        handle: 'ne',\n        x: bounds.x + bounds.width - hs / 2,\n        y: bounds.y - hs / 2\n      }, {\n        handle: 'w',\n        x: bounds.x - hs / 2,\n        y: bounds.y + bounds.height / 2 - hs / 2\n      }, {\n        handle: 'e',\n        x: bounds.x + bounds.width - hs / 2,\n        y: bounds.y + bounds.height / 2 - hs / 2\n      }, {\n        handle: 'sw',\n        x: bounds.x - hs / 2,\n        y: bounds.y + bounds.height - hs / 2\n      }, {\n        handle: 's',\n        x: bounds.x + bounds.width / 2 - hs / 2,\n        y: bounds.y + bounds.height - hs / 2\n      }, {\n        handle: 'se',\n        x: bounds.x + bounds.width - hs / 2,\n        y: bounds.y + bounds.height - hs / 2\n      }];\n      return handles.find(h => point.x >= h.x && point.x <= h.x + hs && point.y >= h.y && point.y <= h.y + hs) ? {\n        element: selected,\n        handle: handles.find(h => point.x >= h.x && point.x <= h.x + hs && point.y >= h.y && point.y <= h.y + hs).handle\n      } : null;\n    }\n    render() {\n      const canvas = this.canvasRef.nativeElement;\n      this.ctx.clearRect(0, 0, canvas.width, canvas.height);\n      this.ctx.save();\n      const zoom = this.canvasService.zoom;\n      const pan = this.canvasService.pan;\n      this.ctx.translate(pan.x, pan.y);\n      this.ctx.scale(zoom, zoom);\n      const elements = [...this.canvasService.elements].sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0));\n      elements.forEach(element => {\n        this.drawElement(element);\n      });\n      const selected = elements.find(el => el.isSelected);\n      if (selected) {\n        const bounds = this.getElementBounds(selected);\n        this.drawSelectionHandles(bounds);\n      }\n      this.ctx.restore();\n    }\n    drawElement(element) {\n      this.ctx.save();\n      this.ctx.strokeStyle = element.strokeColor;\n      this.ctx.fillStyle = element.fillColor;\n      this.ctx.lineWidth = element.strokeWidth;\n      const centerX = element.x + (element.width || 0) / 2;\n      const centerY = element.y + (element.height || 0) / 2;\n      if (element.rotation) {\n        this.ctx.translate(centerX, centerY);\n        this.ctx.rotate(element.rotation * Math.PI / 180);\n        this.ctx.translate(-centerX, -centerY);\n      }\n      if (element.isSelected) {\n        this.ctx.strokeStyle = '#4CAF50';\n        this.ctx.lineWidth = element.strokeWidth + 2;\n      }\n      switch (element.type) {\n        case 'rectangle':\n          this.drawRectangle(element);\n          break;\n        case 'circle':\n          this.drawCircle(element);\n          break;\n        case 'ellipse':\n          this.drawEllipse(element);\n          break;\n        case 'line':\n          this.drawLine(element);\n          break;\n        case 'arrow':\n          this.drawArrow(element);\n          break;\n        case 'triangle':\n          this.drawTriangle(element);\n          break;\n        case 'star':\n          this.drawStar(element);\n          break;\n        case 'polygon':\n          this.drawPolygon(element);\n          break;\n        case 'freedraw':\n          this.drawFreeDraw(element);\n          break;\n        case 'text':\n          this.drawText(element);\n          break;\n      }\n      this.ctx.restore();\n    }\n    drawRectangle(element) {\n      const w = element.width || 0;\n      const h = element.height || 0;\n      this.ctx.fillRect(element.x, element.y, w, h);\n      this.ctx.strokeRect(element.x, element.y, w, h);\n    }\n    drawCircle(element) {\n      const radius = Math.abs(element.width || 0) / 2;\n      const centerX = element.x + (element.width || 0) / 2;\n      const centerY = element.y + (element.height || 0) / 2;\n      this.ctx.beginPath();\n      this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      this.ctx.fill();\n      this.ctx.stroke();\n    }\n    drawEllipse(element) {\n      const radiusX = Math.abs(element.width || 0) / 2;\n      const radiusY = Math.abs(element.height || 0) / 2;\n      const centerX = element.x + (element.width || 0) / 2;\n      const centerY = element.y + (element.height || 0) / 2;\n      this.ctx.beginPath();\n      this.ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);\n      this.ctx.fill();\n      this.ctx.stroke();\n    }\n    drawLine(element) {\n      const endX = element.x + (element.width || 0);\n      const endY = element.y + (element.height || 0);\n      this.ctx.beginPath();\n      this.ctx.moveTo(element.x, element.y);\n      this.ctx.lineTo(endX, endY);\n      this.ctx.stroke();\n    }\n    drawArrow(element) {\n      const endX = element.x + (element.width || 0);\n      const endY = element.y + (element.height || 0);\n      // Draw line\n      this.ctx.beginPath();\n      this.ctx.moveTo(element.x, element.y);\n      this.ctx.lineTo(endX, endY);\n      this.ctx.stroke();\n      // Draw arrowhead\n      const angle = Math.atan2(endY - element.y, endX - element.x);\n      const headLength = 15;\n      this.ctx.beginPath();\n      this.ctx.moveTo(endX, endY);\n      this.ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6), endY - headLength * Math.sin(angle - Math.PI / 6));\n      this.ctx.moveTo(endX, endY);\n      this.ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6), endY - headLength * Math.sin(angle + Math.PI / 6));\n      this.ctx.stroke();\n    }\n    drawFreeDraw(element) {\n      if (!element.points || element.points.length < 2) return;\n      this.ctx.beginPath();\n      this.ctx.moveTo(element.points[0].x, element.points[0].y);\n      for (let i = 1; i < element.points.length; i++) {\n        this.ctx.lineTo(element.points[i].x, element.points[i].y);\n      }\n      this.ctx.stroke();\n    }\n    drawText(element) {\n      if (!element.text) return;\n      const size = element.fontSize ?? 16;\n      const family = element.fontFamily ?? 'Arial';\n      const style = element.fontStyle ?? 'normal';\n      const weight = element.fontWeight ?? 'normal';\n      this.ctx.font = `${style} ${weight} ${size}px ${family}`;\n      this.ctx.fillStyle = element.strokeColor || '#000';\n      this.ctx.fillText(element.text, element.x, element.y + size);\n      if (element.isSelected) {\n        const boxW = element.width || this.ctx.measureText(element.text).width;\n        const boxH = element.height || size;\n        this.ctx.strokeRect(element.x - 2, element.y, boxW + 4, boxH + 4);\n      }\n    }\n    getElementBounds(el) {\n      if (el.type === 'text') {\n        const size = el.fontSize ?? 16;\n        const family = el.fontFamily ?? 'Arial';\n        const style = el.fontStyle ?? 'normal';\n        const weight = el.fontWeight ?? 'normal';\n        this.ctx.save();\n        this.ctx.font = `${style} ${weight} ${size}px ${family}`;\n        const width = el.width || this.ctx.measureText(el.text || '').width;\n        this.ctx.restore();\n        const height = el.height || size;\n        return {\n          x: el.x,\n          y: el.y,\n          width,\n          height\n        };\n      }\n      return {\n        x: el.x,\n        y: el.y,\n        width: el.width || 0,\n        height: el.height || 0\n      };\n    }\n    measureElementWidth(el) {\n      if (el.type === 'text') {\n        const size = el.fontSize ?? 16;\n        const family = el.fontFamily ?? 'Arial';\n        const style = el.fontStyle ?? 'normal';\n        const weight = el.fontWeight ?? 'normal';\n        this.ctx.save();\n        this.ctx.font = `${style} ${weight} ${size}px ${family}`;\n        const width = this.ctx.measureText(el.text || '').width;\n        this.ctx.restore();\n        return width;\n      }\n      return el.width || 0;\n    }\n    measureElementHeight(el) {\n      if (el.type === 'text') {\n        return el.height || el.fontSize || 16;\n      }\n      return el.height || 0;\n    }\n    drawSelectionHandles(bounds) {\n      const hs = this.handleSize;\n      const handles = [{\n        x: bounds.x - hs / 2,\n        y: bounds.y - hs / 2\n      }, {\n        x: bounds.x + bounds.width / 2 - hs / 2,\n        y: bounds.y - hs / 2\n      }, {\n        x: bounds.x + bounds.width - hs / 2,\n        y: bounds.y - hs / 2\n      }, {\n        x: bounds.x - hs / 2,\n        y: bounds.y + bounds.height / 2 - hs / 2\n      }, {\n        x: bounds.x + bounds.width - hs / 2,\n        y: bounds.y + bounds.height / 2 - hs / 2\n      }, {\n        x: bounds.x - hs / 2,\n        y: bounds.y + bounds.height - hs / 2\n      }, {\n        x: bounds.x + bounds.width / 2 - hs / 2,\n        y: bounds.y + bounds.height - hs / 2\n      }, {\n        x: bounds.x + bounds.width - hs / 2,\n        y: bounds.y + bounds.height - hs / 2\n      } // se\n      ];\n      this.ctx.save();\n      this.ctx.fillStyle = '#4CAF50';\n      this.ctx.strokeStyle = '#2e7d32';\n      handles.forEach(h => {\n        this.ctx.fillRect(h.x, h.y, hs, hs);\n        this.ctx.strokeRect(h.x, h.y, hs, hs);\n      });\n      this.ctx.restore();\n    }\n    startInlineEdit(el) {\n      const bounds = this.getElementBounds(el);\n      const zoom = this.canvasService.zoom;\n      const pan = this.canvasService.pan;\n      this.editingElementId = el.id;\n      this.editValue = el.text || '';\n      this.editPosition = {\n        top: bounds.y * zoom + pan.y,\n        left: bounds.x * zoom + pan.x,\n        width: Math.max(bounds.width, 100) * zoom,\n        height: Math.max(bounds.height, el.fontSize || 16) * zoom + 8\n      };\n      setTimeout(() => this.textEditorRef?.nativeElement.focus(), 0);\n    }\n    commitInlineEdit() {\n      if (!this.editingElementId) return;\n      const target = this.canvasService.elements.find(e => e.id === this.editingElementId);\n      if (!target) {\n        this.cancelInlineEdit();\n        return;\n      }\n      const text = this.editValue;\n      const width = this.measureElementWidth({\n        ...target,\n        text\n      });\n      const height = this.measureElementHeight({\n        ...target,\n        text\n      });\n      this.canvasService.updateElement(target.id, {\n        text,\n        width,\n        height\n      });\n      this.historyService.addState(this.canvasService.getState());\n      this.cancelInlineEdit();\n    }\n    cancelInlineEdit() {\n      this.editingElementId = null;\n      this.editValue = '';\n    }\n    onInlineEditKeydown(event) {\n      if (event.key === 'Enter' && !event.shiftKey) {\n        event.preventDefault();\n        this.commitInlineEdit();\n      }\n      if (event.key === 'Escape') {\n        event.preventDefault();\n        this.cancelInlineEdit();\n      }\n    }\n    drawTriangle(element) {\n      const w = element.width || 0;\n      const h = element.height || 0;\n      const x1 = element.x + w / 2;\n      const y1 = element.y;\n      const x2 = element.x + w;\n      const y2 = element.y + h;\n      const x3 = element.x;\n      const y3 = element.y + h;\n      this.ctx.beginPath();\n      this.ctx.moveTo(x1, y1);\n      this.ctx.lineTo(x2, y2);\n      this.ctx.lineTo(x3, y3);\n      this.ctx.closePath();\n      this.ctx.fill();\n      this.ctx.stroke();\n    }\n    drawStar(element, spikes = 5) {\n      const w = element.width || 0;\n      const h = element.height || 0;\n      const outerRadius = Math.max(Math.abs(w), Math.abs(h)) / 2;\n      const innerRadius = outerRadius / 2.5;\n      const centerX = element.x + w / 2;\n      const centerY = element.y + h / 2;\n      this.ctx.beginPath();\n      for (let i = 0; i < spikes * 2; i++) {\n        const radius = i % 2 === 0 ? outerRadius : innerRadius;\n        const angle = Math.PI / spikes * i - Math.PI / 2;\n        const x = centerX + Math.cos(angle) * radius;\n        const y = centerY + Math.sin(angle) * radius;\n        if (i === 0) {\n          this.ctx.moveTo(x, y);\n        } else {\n          this.ctx.lineTo(x, y);\n        }\n      }\n      this.ctx.closePath();\n      this.ctx.fill();\n      this.ctx.stroke();\n    }\n    drawPolygon(element, sides = 6) {\n      if (sides < 3) return;\n      const w = element.width || 0;\n      const h = element.height || 0;\n      const radius = Math.min(Math.abs(w), Math.abs(h)) / 2;\n      const centerX = element.x + w / 2;\n      const centerY = element.y + h / 2;\n      this.ctx.beginPath();\n      for (let i = 0; i < sides; i++) {\n        const angle = Math.PI * 2 / sides * i - Math.PI / 2;\n        const x = centerX + radius * Math.cos(angle);\n        const y = centerY + radius * Math.sin(angle);\n        if (i === 0) {\n          this.ctx.moveTo(x, y);\n        } else {\n          this.ctx.lineTo(x, y);\n        }\n      }\n      this.ctx.closePath();\n      this.ctx.fill();\n      this.ctx.stroke();\n    }\n    static {\n      this.ɵfac = function CanvasComponent_Factory(t) {\n        return new (t || CanvasComponent)(i0.ɵɵdirectiveInject(i1.CanvasService), i0.ɵɵdirectiveInject(i2.ToolService), i0.ɵɵdirectiveInject(i3.HistoryService));\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: CanvasComponent,\n        selectors: [[\"app-canvas\"]],\n        viewQuery: function CanvasComponent_Query(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵviewQuery(_c0, 5);\n            i0.ɵɵviewQuery(_c1, 5);\n          }\n          if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvasRef = _t.first);\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.textEditorRef = _t.first);\n          }\n        },\n        hostBindings: function CanvasComponent_HostBindings(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵlistener(\"resize\", function CanvasComponent_resize_HostBindingHandler() {\n              return ctx.resizeCanvas();\n            }, false, i0.ɵɵresolveWindow)(\"keydown\", function CanvasComponent_keydown_HostBindingHandler($event) {\n              return ctx.handleKeyDown($event);\n            }, false, i0.ɵɵresolveWindow)(\"dblclick\", function CanvasComponent_dblclick_HostBindingHandler($event) {\n              return ctx.onDoubleClick($event);\n            })(\"wheel\", function CanvasComponent_wheel_HostBindingHandler($event) {\n              return ctx.onWheel($event);\n            });\n          }\n        },\n        decls: 4,\n        vars: 1,\n        consts: [[\"canvas\", \"\"], [\"textEditor\", \"\"], [1, \"canvas-container\"], [3, \"mousedown\", \"mousemove\", \"mouseup\"], [\"class\", \"text-editor\", \"spellcheck\", \"false\", 3, \"ngStyle\", \"ngModel\", \"ngModelChange\", \"keydown\", \"blur\", \"mousedown\", 4, \"ngIf\"], [\"spellcheck\", \"false\", 1, \"text-editor\", 3, \"ngModelChange\", \"keydown\", \"blur\", \"mousedown\", \"ngStyle\", \"ngModel\"]],\n        template: function CanvasComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            const _r1 = i0.ɵɵgetCurrentView();\n            i0.ɵɵelementStart(0, \"div\", 2)(1, \"canvas\", 3, 0);\n            i0.ɵɵlistener(\"mousedown\", function CanvasComponent_Template_canvas_mousedown_1_listener($event) {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.onMouseDown($event));\n            })(\"mousemove\", function CanvasComponent_Template_canvas_mousemove_1_listener($event) {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.onMouseMove($event));\n            })(\"mouseup\", function CanvasComponent_Template_canvas_mouseup_1_listener($event) {\n              i0.ɵɵrestoreView(_r1);\n              return i0.ɵɵresetView(ctx.onMouseUp($event));\n            });\n            i0.ɵɵelementEnd();\n            i0.ɵɵtemplate(3, CanvasComponent_textarea_3_Template, 2, 7, \"textarea\", 4);\n            i0.ɵɵelementEnd();\n          }\n          if (rf & 2) {\n            i0.ɵɵadvance(3);\n            i0.ɵɵproperty(\"ngIf\", ctx.editingElementId);\n          }\n        },\n        dependencies: [i4.NgIf, i4.NgStyle, i5.DefaultValueAccessor, i5.NgControlStatus, i5.NgModel],\n        styles: [\".canvas-container[_ngcontent-%COMP%]{flex:1;position:relative;overflow:hidden;background:var(--surface);background-image:linear-gradient(var(--grid-line, #e0e0e0) 1px,transparent 1px),linear-gradient(90deg,var(--grid-line, #e0e0e0) 1px,transparent 1px);background-size:20px 20px}canvas[_ngcontent-%COMP%]{width:100%;height:100%;display:block;cursor:crosshair}.text-editor[_ngcontent-%COMP%]{position:absolute;padding:8px 10px;border:1px solid var(--accent);border-radius:10px;background:#fffffff2;color:var(--text);font:inherit;box-shadow:var(--shadow-1);resize:none;outline:none;z-index:200;line-height:1.2}\"]\n      });\n    }\n  }\n  return CanvasComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}